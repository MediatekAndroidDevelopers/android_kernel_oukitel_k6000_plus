#include <linux/i2c.h>#include <linux/gpio.h>#include <linux/delay.h>#include <linux/slab.h>#include <linux/module.h>#include <linux/of_gpio.h>#include <linux/of.h>#include <linux/of_irq.h>#include <linux/platform_device.h>#include <linux/interrupt.h>#include <linux/time.h>#include <linux/kthread.h>#include <typec.h>#include <linux/hct_include/hct_project_all_config.h>#define PI5USB30216A_I2C_NAME "PI5USB30216A"//static int trysink_flag =0;#define ACCDET_PIN_PLUG_IN        (1)#define ACCDET_PIN_PLUG_OUT       (0)int accdet_typec_state = ACCDET_PIN_PLUG_OUT;static DEFINE_MUTEX(pi5usb_i2c_lock);static struct usbtypc *g_exttypec;static void trigger_driver(struct usbtypc *typec, int type, int stat); static int pusb30216A_i2c_read(struct i2c_client *client,char *rxData, int length){	return i2c_master_recv(client,rxData, length);	 }static int pusb30216A_i2c_write(struct i2c_client *client,char *txData, int length){	return i2c_master_send(client, txData, length);}#ifndef USE_EARLY_SUSPENDstatic int pi5usb_suspend(struct i2c_client *client, pm_message_t msg) {	//wait to do something	return 0;}static int pi5usb_resume(struct i2c_client *client){	//wait to do something	return 0;}#else static void pi5usb_early_suspend(struct early_suspend *h) {	//wait to do something}static void pi5usb_late_resume(struct early_suspend *h){	//wait to do something#ifdef CONFIG_OF#else    mt_eint_unmask(CUST_EINT_CC_DECODER_NUM);#endif}#endifstatic int pi5usb_power_onoff(int value){/*    if(value)        hwPowerOn(MT6331_POWER_LDO_VMC, VOL_3300, "tusb");    else        hwPowerDown(MT6331_POWER_LDO_VMC,"tusb");*/    printk(KERN_ERR "justin test printk\n");    return 0;}int typec_irqnum=0;extern int cur_eint_state;extern int accdet_irq;extern struct work_struct accdet_eint_work;extern irqreturn_t accdet_eint_func(int irq, void *data);extern int typec_recheck_flag;void pusb_eint_work(struct work_struct *work){    char rx_buffer[4];    char tx_buffer[4]={0x00};            u8 attached_value = 0;	u8 control_value = 0;	u8 int_mask = 0;	u8 cc_status =0;	int i;	u8 attach_current_mode=0;#if defined(CONFIG_MTK_LEGACY)	printk("%s usb_id_pin=%d\n", __func__,  gpio_get_value(g_exttypec->usb_id_pin));#else	printk("%s usb_id_pin=%d\n",  __func__, __gpio_get_value(g_exttypec->usb_id_pin));#endif	pusb30216A_i2c_read(g_exttypec->i2c_hd, rx_buffer, 2);			//Read Control register data	control_value = rx_buffer[1]; 	int_mask = (control_value | 0x01);	   	tx_buffer[1] = int_mask;	pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);				//Set to control register	pusb30216A_i2c_read(g_exttypec->i2c_hd, rx_buffer, 4);	attached_value = (rx_buffer[3] &0x1c)>>2;							//Get the Attach Port Status data 	cc_status = (rx_buffer[3] &0x03);									//Get the CC Status data	attach_current_mode = (rx_buffer[3] &0x60)>>5;						//Get Attached Host Charging Current status data 	printk("pi5usb attached value:%x %x %x %x %x\n",rx_buffer[0],rx_buffer[1],rx_buffer[2],rx_buffer[3],attached_value);	if((rx_buffer[2] &0x02)>>1)	{		//Detach event		printk("pi5usb30216c typec detach event.\n");		tx_buffer[1]=0x57;							//enter trySNK DRP with 330uA current detect.		pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);	}	if(rx_buffer[2] &0x01)			{		//Attach event		printk("pi5usb30216c typec attach event.\n");	}	if((attached_value==0x00))	{		//it is a standby status...		printk("pi5usb30216c standby status.\n");	}	if((attached_value==0x04))	{		//it is a debug accessory to do...		printk("pi5usb30216c debug accessory attached.\n");    	}	if(accdet_typec_state==ACCDET_PIN_PLUG_IN){ 			printk("pi5usb30216c audio accessory attached.\n");			typec_recheck_flag = 0;		    accdet_eint_func(accdet_irq, NULL);			accdet_typec_state = ACCDET_PIN_PLUG_OUT;			printk("pi5usb30216c accdet_typec_state -->ACCDET_PIN_PLUG_OUT .\n");		}		else			{    if(attached_value==0x03)    {		//it is a audio accessory to do...					printk("pi5usb30216c accdet_typec_state -->ACCDET_PIN_PLUG_IN.\n");					cur_eint_state = ACCDET_PIN_PLUG_OUT;					typec_recheck_flag =1;					accdet_eint_func(accdet_irq, NULL);					accdet_typec_state=ACCDET_PIN_PLUG_IN;					printk("pi5usb30216c accdet_eint_func end.\n");				}    }        if(attached_value==0x02)    {		//host do nothing return.		printk("pi5usb30216c host attached.\n");		if(cc_status == 0x01)		{			printk("CC1 make connection.\n");		}		if(cc_status == 0x02)		{			printk("CC2 make connection.\n");		}		if(attach_current_mode ==0x00)		{			printk("Standby current status.\n");		}		if(attach_current_mode ==0x01)		{			printk("Default current mode.\n");		}		if(attach_current_mode ==0x02)		{			printk("1.5A current mode.\n");		}		if(attach_current_mode ==0x03)		{			printk("3A current mode.\n");		}        //return;    }	if(attached_value==0x01)    {		//device do nothing return. ID to control VBUS out		printk("pi5usb30216c device attached.\n");		if(cc_status == 0x01)		{			printk("CC1 make connection.\n");		}		if(cc_status == 0x02)		{			printk("CC2 make connection.\n");		}		tx_buffer[1]=0x47;							//enter trySNK DRP with 80uA default current detect.       		pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);        //return;    }	if(attached_value==0x05)    {		//device do nothing return. ID to control VBUS out		printk("pi5usb30216c device with active cable attached.\n");		if(cc_status == 0x01)		{			printk("CC1 make connection.\n");		}		if(cc_status == 0x02)		{			printk("CC2 make connection.\n");		}		tx_buffer[1]=0x47;							//enter trySNK DRP with 80uA default current detect.       		pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);       // return;    }		pusb30216A_i2c_read(g_exttypec->i2c_hd, rx_buffer, 2);			//Read Control register data		control_value = rx_buffer[1]; 		int_mask = (control_value &0xFE);									//Unmask Interrupt  		tx_buffer[1] = int_mask;		pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);				//Set to control register	if (!g_exttypec->en_irq) {		mdelay(100);		for (i=0;i<10;i--)			{				printk("while typec %s : gpio2 status: %d \n", __func__, gpio_get_value(2));				if (gpio_get_value(2))				{		printk("Enable IRQ\n");		g_exttypec->en_irq = 1;					gpio_set_value(__HCT_TYPEC_EINT_PIN_NUM__ ,1);    //Set the typec eint num		enable_irq(g_exttypec->irqnum);					break;				}			 	else		 		{		 			mdelay(1000);		 		}			}	}	printk("typec %s : gpio89 status: %d \n", __func__, gpio_get_value(g_exttypec->usb_id_pin));}static void trigger_driver(struct usbtypc *typec, int type, int stat){	printk("trigger_driver: type:%d, stat:%d\n", type, stat);	if (type == DEVICE_TYPE && typec->device_driver) {		struct typec_switch_data *drv = typec->device_driver;		if ((stat == DISABLE) && (drv->disable)		    && (drv->on == ENABLE)) {			drv->disable(drv->priv_data);			drv->on = DISABLE;			printk("Device Disabe\n");		} else if ((stat == ENABLE) && (drv->enable)			   && (drv->on == DISABLE)) {			drv->enable(drv->priv_data);			drv->on = ENABLE;			printk("Device Enable\n");		} else {			printk("No device driver to enable\n");		}	} else if (type == HOST_TYPE && typec->host_driver) {		struct typec_switch_data *drv = typec->host_driver;		if ((stat == DISABLE) && (drv->disable)		    && (drv->on == ENABLE)) {			drv->disable(drv->priv_data);			drv->on = DISABLE;			printk("Host Disable\n");		} else if ((stat == ENABLE) &&			   (drv->enable) && (drv->on == DISABLE)) {			drv->enable(drv->priv_data);			drv->on = ENABLE;			printk("Host Enable\n");		} else {			printk("No device driver to enable\n");		}	} else {		printk("wrong way\n");	}}int register_typec_switch_callback(struct typec_switch_data *new_driver){	printk("Register driver %s %d\n", new_driver->name, new_driver->type);	if (new_driver->type == DEVICE_TYPE) {		g_exttypec->device_driver = new_driver;		g_exttypec->device_driver->on = 0;		return 0;	}	if (new_driver->type == HOST_TYPE) {		g_exttypec->host_driver = new_driver;		g_exttypec->host_driver->on = 0;		printk("Register driver %s %d\n", new_driver->name, new_driver->type);		return 0;	}	return -1;}EXPORT_SYMBOL_GPL(register_typec_switch_callback);int unregister_typec_switch_callback(struct typec_switch_data *new_driver){	printk("Unregister driver %s %d\n", new_driver->name, new_driver->type);	if ((new_driver->type == DEVICE_TYPE) && (g_exttypec->device_driver == new_driver))		g_exttypec->device_driver = NULL;	if ((new_driver->type == HOST_TYPE) && (g_exttypec->host_driver == new_driver))		g_exttypec->host_driver = NULL;	return 0;}EXPORT_SYMBOL_GPL(unregister_typec_switch_callback);#ifdef CONFIG_OFstatic irqreturn_t pi5usb_eint_isr(int irqnum, void *data){	struct usbtypc *typec = data;	printk("pi5usb_eint_isr Disable IRQ\n");	if (g_exttypec->en_irq) {		printk("Disable IRQ\n");		disable_irq_nosync(irqnum);		gpio_set_value(__HCT_TYPEC_EINT_PIN_NUM__ ,0);       //Set the typec eint num		g_exttypec->en_irq = 0;	}	schedule_work(&typec->eint_work);	return IRQ_HANDLED;}int pi5usb_eint_init(struct usbtypc *typec){	int retval = 0;	u32 ints[2] = { 0, 0 };	struct device_node *node;	unsigned int debounce, gpiopin;	node = of_find_compatible_node(NULL, NULL, "mediatek,usb_c_pinctrl");	if (node) {		of_property_read_u32_array(node, "debounce", ints, ARRAY_SIZE(ints));		debounce = ints[1];		gpiopin = ints[0];		gpio_set_debounce(gpiopin, debounce);	}	typec->irqnum = irq_of_parse_and_map(node, 0);	typec->en_irq = 1;	printk("request_irq irqnum=0x%x\n", typec->irqnum);	retval =	    request_irq(typec->irqnum, pi5usb_eint_isr, IRQF_TRIGGER_FALLING | IRQF_ONESHOT, "pi5usb_eint", typec);	if (retval != 0) {		printk("request_irq fail, ret %d, irqnum %d!!!\n", retval,			    typec->irqnum);	}	return retval;}//usb id as eintstatic void pusb_usbid_eint_work(struct work_struct *work){	static u8 usdid = 1;#if defined(CONFIG_MTK_LEGACY)	usdid = gpio_get_value(g_exttypec->usb_id_pin);#else	usdid = __gpio_get_value(g_exttypec->usb_id_pin);#endif		printk("%s usb_id_pin=%d\n", __func__, usdid);    if(usdid == 0) // this means otg is plugin    {		printk("detect cable insertion\n");		mdelay(200);		if (g_exttypec->host_driver && (g_exttypec->host_driver->on == DISABLE))			trigger_driver(g_exttypec, HOST_TYPE, ENABLE);		        irq_set_irq_type(g_exttypec->usbid_irqnum, IRQF_TRIGGER_HIGH);    }    else    {		printk("detect cable removal\n");		if (g_exttypec->host_driver && (g_exttypec->host_driver->on == ENABLE))			trigger_driver(g_exttypec, HOST_TYPE, DISABLE);        irq_set_irq_type(g_exttypec->usbid_irqnum, IRQF_TRIGGER_LOW);    }	if (!g_exttypec->en_usbid_irq) {		printk("%s Enable IRQ=%d\n", __func__, g_exttypec->usbid_irqnum);		g_exttypec->en_usbid_irq = 1;		enable_irq(g_exttypec->usbid_irqnum);	}}static irqreturn_t pi5usb_usbid_isr(int irq, void *data){	struct usbtypc *typec = data;	if (typec->en_usbid_irq) {		disable_irq_nosync(irq);		printk("%s Disable IRQ=%d\n", __func__, irq);		typec->en_usbid_irq = 0;	}	schedule_work(&typec->usbid_eint_work);	return IRQ_HANDLED;}int pi5usb_usbid_eint_init(struct usbtypc *typec){	int ret = 0;	u32 ints[2] = { 0, 0 };	unsigned int gpiopin, debounce;	struct device_node *node;	static u8 usdid = 1;	node = of_find_compatible_node(NULL, NULL, "mediatek,usb_c_id");	if (node) {		of_property_read_u32_array(node, "debounce", ints, ARRAY_SIZE(ints));		debounce = ints[1];		gpiopin = ints[0];		gpio_set_debounce(gpiopin, debounce);		printk("gpiopin=%d, debounce=%d\n",	gpiopin, debounce);	}	typec->usbid_irqnum = irq_of_parse_and_map(node, 0);	typec->en_usbid_irq = 1;	printk("%s usbid_irqnum=%d\n", __func__, typec->usbid_irqnum);	#if defined(CONFIG_MTK_LEGACY)	usdid = gpio_get_value(typec->usb_id_pin);#else	usdid = __gpio_get_value(typec->usb_id_pin);#endif		printk("%s usb_id_pin=%d\n", __func__, usdid);    if(usdid == 0) // this means otg is plugin        ret = request_irq(typec->usbid_irqnum, pi5usb_usbid_isr,IRQF_TRIGGER_HIGH, "pi5usb_usbid", typec);    else        ret = request_irq(typec->usbid_irqnum, pi5usb_usbid_isr,IRQF_TRIGGER_LOW, "pi5usb_usbid", typec);	if (ret < 0) {		pr_err("%s : failed to request irq\n", __func__);	}	return ret;}#elsestatic void cc_eint_interrupt_handler(void){    schedule_work(&pusb_i2c_data->eint_work);}#endifstatic int pi5usb_init_gpio(void){	int ret = 0;	pinctrl_select_state(g_exttypec->pinctrl, g_exttypec->pin_cfg->typec_as_int);	pinctrl_select_state(g_exttypec->pinctrl, g_exttypec->pin_cfg->typec_usb_id);#if defined(CONFIG_MTK_LEGACY)	printk("%s usb_id_pin=%d\n", __func__,  gpio_get_value(g_exttypec->usb_id_pin));#else	printk("%s usb_id_pin=%d\n",  __func__, __gpio_get_value(g_exttypec->usb_id_pin));#endif	return ret;}static int pi5usb_probe(struct i2c_client *client, const struct i2c_device_id *id){    struct usbtypc *typec;    char tx_buffer[2]={0x20,0x01};    char rx_buffer[4];    int ret;    printk("%s\n", __func__);    pi5usb_power_onoff(1);    pi5usb_init_gpio();    ret = pusb30216A_i2c_read(client, rx_buffer, 4);	printk("typec %s ret: %x, %x, %x, %x \n ", __func__, rx_buffer[0], rx_buffer[1], rx_buffer[2], rx_buffer[3]);    if((ret <0) || (rx_buffer[0] != 0x20))    {    	dev_err(&client->dev, "attached pusb fail\n");        goto exit;    }            printk("%s %s\n", __func__, client->dev.driver->name);    if (!g_exttypec)    	g_exttypec = kzalloc(sizeof(struct usbtypc), GFP_KERNEL);    typec = g_exttypec;    typec->i2c_hd = client;       //intial code.    pusb30216A_i2c_write(typec->i2c_hd,tx_buffer,2);    mdelay(30);        //tx_buffer[1]=0x04;    tx_buffer[1]=0x56;	    pusb30216A_i2c_write(typec->i2c_hd,tx_buffer,2);    //tx_buffer[1]=0x00;    //pusb30216A_i2c_write(typec->i2c_hd,tx_buffer,2);        INIT_WORK(&typec->eint_work, pusb_eint_work);    INIT_WORK(&typec->usbid_eint_work, pusb_usbid_eint_work);#ifdef CONFIG_OF    pi5usb_usbid_eint_init(typec);	pi5usb_eint_init(typec);#else    mt_eint_registration(CUST_EINT_CC_DECODER_NUM, CUST_EINTF_TRIGGER_FALLING, cc_eint_interrupt_handler, 0);// disable auto-unmask    mt_eint_unmask(CUST_EINT_CC_DECODER_NUM);#endif   // mt_set_gpio_out(175, 1);//temp solution for typeC-A detect!    schedule_work(&typec->eint_work);//insert cable power on.    schedule_work(&typec->usbid_eint_work);//insert cable power on.    return 0;    exit:    pi5usb_power_onoff(0);    return -1;}static int pi5usb_remove(struct i2c_client *client){	i2c_unregister_device(client);	kfree(i2c_get_clientdata(client));    pi5usb_power_onoff(0);    return 0;}static const struct i2c_device_id pi5usb_id[] = {	{ PI5USB30216A_I2C_NAME, 0 },	{ }};#ifdef CONFIG_OFstatic const struct of_device_id pi5usb_of_match[] = {		{.compatible = "mediatek,usb_type_c_pi5usb"},		{},	};#elsestatic struct i2c_board_info __initdata pi5usb_i2c_boardinfo[] = {	{		I2C_BOARD_INFO(PI5USB30216A_I2C_NAME, (0x1d)),	},};#endifstatic struct i2c_driver pi5usb_i2c_driver = {	.driver = {		.name = PI5USB30216A_I2C_NAME,		.owner = THIS_MODULE,#ifdef CONFIG_OF		.of_match_table = pi5usb_of_match,#endif		},	.probe		= pi5usb_probe,	.remove		= pi5usb_remove,	#if !defined(USE_EARLY_SUSPEND)        .suspend            = pi5usb_suspend,    .resume             = pi5usb_resume,    #endif	.id_table	= pi5usb_id,};static int usbc_pinctrl_probe(struct platform_device *pdev){	int retval = 0;	struct usbtypc *typec;	struct device_node *node = NULL;	unsigned int usb_id_pin;	printk("%s\n", __func__);	if (!g_exttypec)		g_exttypec = kzalloc(sizeof(struct usbtypc), GFP_KERNEL);	typec = g_exttypec;	typec->pinctrl = devm_pinctrl_get(&pdev->dev);	if (IS_ERR(typec->pinctrl)) {		printk("Cannot find usb pinctrl!\n");	} else {		typec->pin_cfg = kzalloc(sizeof(struct usbc_pin_ctrl), GFP_KERNEL);		printk("pinctrl=%p\n", typec->pinctrl);		typec->pin_cfg->typec_as_int = pinctrl_lookup_state(typec->pinctrl, "typec_as_int");		if (IS_ERR(typec->pin_cfg->typec_as_int))			printk("Can *NOT* find typec_as_int\n");		else			printk("Find typec_as_int\n");		typec->pin_cfg->typec_usb_id = pinctrl_lookup_state(typec->pinctrl, "typec_usb_id");		if (IS_ERR(typec->pin_cfg->typec_usb_id))			printk("Can *NOT* find typec_usb_id\n");		else			printk("Find typec_usb_id\n");		node = of_find_compatible_node(NULL, NULL, "mediatek,usb_c_pinctrl");		if (node)		{			if (of_property_read_u32_index(node, "typec_usbid_gpio", 1, &usb_id_pin)) {			    	printk("typec usb id gpio fail~~~\n");				g_exttypec->usb_id_pin = 0;			}			else {				g_exttypec->usb_id_pin = usb_id_pin;				printk("find typec_usbid_gpio = %x \n", g_exttypec->usb_id_pin);			}		}		printk("Finish parsing pinctrl\n");	}	return retval;}static int usbc_pinctrl_remove(struct platform_device *pdev){	return 0;}static const struct of_device_id usb_pinctrl_ids[] = {	{.compatible = "mediatek,usb_c_pinctrl",},	{},};static struct platform_driver usbc_pinctrl_driver = {	.probe = usbc_pinctrl_probe,	.remove = usbc_pinctrl_remove,	.driver = {		.name = "usbc_pinctrl",#ifdef CONFIG_OF		.of_match_table = usb_pinctrl_ids,#endif	},};static int __init pi5usb_i2c_init(void){	int ret = 0;	printk("typec %s enter. \n", __func__);	ret = platform_driver_register(&usbc_pinctrl_driver);	if (!ret) {		printk("register usbc pinctrl succeed!!\n");		ret = i2c_add_driver(&pi5usb_i2c_driver);		if (ret < 0)			printk("%s: failed to register pi5usb i2c driver",	__func__);		else			printk("pi5usb initialization succeed!!\n");	} else {		printk("register usbc pinctrl fail!!\n");	}	return ret;}static void __exit pi5usb_i2c_exit(void){	i2c_del_driver(&pi5usb_i2c_driver);}fs_initcall(pi5usb_i2c_init);//module_exit(pi5usb_i2c_exit);