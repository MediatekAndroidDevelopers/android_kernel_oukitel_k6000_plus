#include <linux/i2c.h>#include <linux/gpio.h>#include <linux/delay.h>#include <linux/slab.h>#include <linux/module.h>#include <linux/of_gpio.h>#include <linux/of.h>#include <linux/of_irq.h>#include <linux/platform_device.h>#include <linux/interrupt.h>#include <linux/time.h>#include <linux/kthread.h>#include <typec.h>#define PI5USB30216A_I2C_NAME "PI5USB30216A"static int trysink_flag =0;static DEFINE_MUTEX(pi5usb_i2c_lock);static struct usbtypc *g_exttypec;static void trigger_driver(struct usbtypc *typec, int type, int stat); static int pusb30216A_i2c_read(struct i2c_client *client,char *rxData, int length){	return i2c_master_recv(client,rxData, length);	 }static int pusb30216A_i2c_write(struct i2c_client *client,char *txData, int length){	return i2c_master_send(client, txData, length);}#ifndef USE_EARLY_SUSPENDstatic int pi5usb_suspend(struct i2c_client *client, pm_message_t msg) {	//wait to do something	return 0;}static int pi5usb_resume(struct i2c_client *client){	//wait to do something	return 0;}#else static void pi5usb_early_suspend(struct early_suspend *h) {	//wait to do something}static void pi5usb_late_resume(struct early_suspend *h){	//wait to do something#ifdef CONFIG_OF#else    mt_eint_unmask(CUST_EINT_CC_DECODER_NUM);#endif}#endifstatic int pi5usb_power_onoff(int value){/*    if(value)        hwPowerOn(MT6331_POWER_LDO_VMC, VOL_3300, "tusb");    else        hwPowerDown(MT6331_POWER_LDO_VMC,"tusb");*/    printk(KERN_ERR "justin test printk\n");    return 0;}static void pusb_eint_work(struct work_struct *work){    char rx_buffer[4];    char tx_buffer[4]={0x00};        u8 attached_value = 0;//    static int uart_flag =0;#if defined(CONFIG_MTK_LEGACY)	printk("%s usb_id_pin=%d\n", __func__,  gpio_get_value(g_exttypec->usb_id_pin));#else	printk("%s usb_id_pin=%d\n",  __func__, __gpio_get_value(g_exttypec->usb_id_pin));#endif    pusb30216A_i2c_read(g_exttypec->i2c_hd, rx_buffer, 4);    attached_value = (rx_buffer[3] &0x1c)>>2;    printk("pi5usb attached value:%x %x %x %x %x %x\n",rx_buffer[0],rx_buffer[1],rx_buffer[2],rx_buffer[3],attached_value,trysink_flag);//    printk("11justin test for gpio(%d)\n",mt_get_gpio_in(GPIO_OTG_IDDIG_EINT_PIN));/*    if((attached_value==0x04)&&(uart_flag==0))   //debug accessory     {    //it is a debug accessory to do ...    //    mt_set_gpio_dir(175, 1);    //    mt_set_gpio_out(175, 0);        uart_flag = 1;    }     if((attached_value==0x00)&&(uart_flag == 1))      {        uart_flag = 0;        mt_set_gpio_out(175, 1);    }*/    if((rx_buffer[2] &0x02)>>1)//unattached.    {        trysink_flag=0;        tx_buffer[1]=0x04;//enter DRP.        //pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);    }        if(attached_value==0x03)    {    //it is a audio accessory to do...	printk("pi5usb host\n");    }        if(attached_value==0x02)    {    //host device do nothing return.	printk("pi5usb host\n");#ifdef CONFIG_OF	if (!g_exttypec->en_irq) {		printk("Enable IRQ\n");		g_exttypec->en_irq = 1;		enable_irq(g_exttypec->irqnum);	}#else    mt_eint_unmask(CUST_EINT_CC_DECODER_NUM);#endif        return;    }        if(attached_value==0x01)//device and do trysink flow    {/*    	        if(trysink_flag==0)        {            tx_buffer[1]=0x01;#if 0            printk("justin test for gpio(%d)\n",mt_get_gpio_in(GPIO_OTG_IDDIG_EINT_PIN));            pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);//enter UFP.            printk("justin test for gpio(%d)\n",mt_get_gpio_in(GPIO_OTG_IDDIG_EINT_PIN));            mdelay(600);  //delay 600ms for trysink                         printk("justin test for gpio(%d)\n",mt_get_gpio_in(GPIO_OTG_IDDIG_EINT_PIN));#endif            pusb30216A_i2c_read(g_exttypec->i2c_hd, rx_buffer, 4);            printk("pi5usb attached value:%x %x %x %x %x %x\n",rx_buffer[0],rx_buffer[1],rx_buffer[2],rx_buffer[3],attached_value,trysink_flag);                        if((rx_buffer[3] &0x80)>>7)            {                printk("trySNK host attached\n");            }            else            {            //try sink fail, reintial                 tx_buffer[1]=0x05;                pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);                mdelay(50);                tx_buffer[1]=0x01;                pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);                mdelay(30);                tx_buffer[1]=0x05;                pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);                mdelay(30);            }            trysink_flag=1;                        mdelay(20);            tx_buffer[1]=0x04;//enter DRP.            pusb30216A_i2c_write(g_exttypec->i2c_hd,tx_buffer,2);        }*/            }#ifdef CONFIG_OF	if (!g_exttypec->en_irq) {		printk("Enable IRQ\n");		g_exttypec->en_irq = 1;		enable_irq(g_exttypec->irqnum);	}#else    mt_eint_unmask(CUST_EINT_CC_DECODER_NUM);#endif}static void trigger_driver(struct usbtypc *typec, int type, int stat){	printk("trigger_driver: type:%d, stat:%d\n", type, stat);	if (type == DEVICE_TYPE && typec->device_driver) {		struct typec_switch_data *drv = typec->device_driver;		if ((stat == DISABLE) && (drv->disable)		    && (drv->on == ENABLE)) {			drv->disable(drv->priv_data);			drv->on = DISABLE;			printk("Device Disabe\n");		} else if ((stat == ENABLE) && (drv->enable)			   && (drv->on == DISABLE)) {			drv->enable(drv->priv_data);			drv->on = ENABLE;			printk("Device Enable\n");		} else {			printk("No device driver to enable\n");		}	} else if (type == HOST_TYPE && typec->host_driver) {		struct typec_switch_data *drv = typec->host_driver;		if ((stat == DISABLE) && (drv->disable)		    && (drv->on == ENABLE)) {			drv->disable(drv->priv_data);			drv->on = DISABLE;			printk("Host Disable\n");		} else if ((stat == ENABLE) &&			   (drv->enable) && (drv->on == DISABLE)) {			drv->enable(drv->priv_data);			drv->on = ENABLE;			printk("Host Enable\n");		} else {			printk("No device driver to enable\n");		}	} else {		printk("wrong way\n");	}}int register_typec_switch_callback(struct typec_switch_data *new_driver){	printk("Register driver %s %d\n", new_driver->name, new_driver->type);	if (new_driver->type == DEVICE_TYPE) {		g_exttypec->device_driver = new_driver;		g_exttypec->device_driver->on = 0;		return 0;	}	if (new_driver->type == HOST_TYPE) {		g_exttypec->host_driver = new_driver;		g_exttypec->host_driver->on = 0;		printk("Register driver %s %d\n", new_driver->name, new_driver->type);		return 0;	}	return -1;}EXPORT_SYMBOL_GPL(register_typec_switch_callback);int unregister_typec_switch_callback(struct typec_switch_data *new_driver){	printk("Unregister driver %s %d\n", new_driver->name, new_driver->type);	if ((new_driver->type == DEVICE_TYPE) && (g_exttypec->device_driver == new_driver))		g_exttypec->device_driver = NULL;	if ((new_driver->type == HOST_TYPE) && (g_exttypec->host_driver == new_driver))		g_exttypec->host_driver = NULL;	return 0;}EXPORT_SYMBOL_GPL(unregister_typec_switch_callback);#ifdef CONFIG_OFstatic irqreturn_t pi5usb_eint_isr(int irqnum, void *data){	struct usbtypc *typec = data;	printk("pi5usb_eint_isr Disable IRQ\n");	if (g_exttypec->en_irq) {		printk("Disable IRQ\n");		disable_irq_nosync(irqnum);		g_exttypec->en_irq = 0;	}	schedule_work(&typec->eint_work);	return IRQ_HANDLED;}int pi5usb_eint_init(struct usbtypc *typec){	int retval = 0;	u32 ints[2] = { 0, 0 };	struct device_node *node;	unsigned int debounce, gpiopin;	node = of_find_compatible_node(NULL, NULL, "mediatek,usb_c_pinctrl");	if (node) {		of_property_read_u32_array(node, "debounce", ints, ARRAY_SIZE(ints));		debounce = ints[1];		gpiopin = ints[0];		gpio_set_debounce(gpiopin, debounce);	}	typec->irqnum = irq_of_parse_and_map(node, 0);	typec->en_irq = 1;	printk("request_irq irqnum=0x%x\n", typec->irqnum);	retval =	    request_irq(typec->irqnum, pi5usb_eint_isr, IRQF_TRIGGER_NONE, "pi5usb_eint", typec);	if (retval != 0) {		printk("request_irq fail, ret %d, irqnum %d!!!\n", retval,			    typec->irqnum);	}	return retval;}//usb id as eintstatic void pusb_usbid_eint_work(struct work_struct *work){	static u8 usdid = 1;#if defined(CONFIG_MTK_LEGACY)	usdid = gpio_get_value(g_exttypec->usb_id_pin);#else	usdid = __gpio_get_value(g_exttypec->usb_id_pin);#endif		printk("%s usb_id_pin=%d\n", __func__, usdid);    if(usdid == 0) // this means otg is plugin    {		printk("detect cable insertion\n");		mdelay(200);		if (g_exttypec->host_driver && (g_exttypec->host_driver->on == DISABLE))			trigger_driver(g_exttypec, HOST_TYPE, ENABLE);		        irq_set_irq_type(g_exttypec->usbid_irqnum, IRQF_TRIGGER_HIGH);    }    else    {		printk("detect cable removal\n");		if (g_exttypec->host_driver && (g_exttypec->host_driver->on == ENABLE))			trigger_driver(g_exttypec, HOST_TYPE, DISABLE);        irq_set_irq_type(g_exttypec->usbid_irqnum, IRQF_TRIGGER_LOW);    }	if (!g_exttypec->en_usbid_irq) {		printk("%s Enable IRQ=%d\n", __func__, g_exttypec->usbid_irqnum);		g_exttypec->en_usbid_irq = 1;		enable_irq(g_exttypec->usbid_irqnum);	}}static irqreturn_t pi5usb_usbid_isr(int irq, void *data){	struct usbtypc *typec = data;	if (typec->en_usbid_irq) {		disable_irq_nosync(irq);		printk("%s Disable IRQ=%d\n", __func__, irq);		typec->en_usbid_irq = 0;	}	schedule_work(&typec->usbid_eint_work);	return IRQ_HANDLED;}void pi5usb_usbid_eint_inverse(void){	printk("%s usbid_irqnum IRQF_TRIGGER_LOW\n", __func__);	irq_set_irq_type(g_exttypec->usbid_irqnum, IRQF_TRIGGER_LOW);}int pi5usb_usbid_eint_init(struct usbtypc *typec){	int ret = 0;	u32 ints[2] = { 0, 0 };	unsigned int gpiopin, debounce;	struct device_node *node;	static u8 usdid = 1;	node = of_find_compatible_node(NULL, NULL, "mediatek,usb_c_id");	if (node) {		of_property_read_u32_array(node, "debounce", ints, ARRAY_SIZE(ints));		debounce = ints[1];		gpiopin = ints[0];		gpio_set_debounce(gpiopin, debounce);		printk("gpiopin=%d, debounce=%d\n",	gpiopin, debounce);	}	typec->usbid_irqnum = irq_of_parse_and_map(node, 0);	typec->en_usbid_irq = 1;	printk("%s usbid_irqnum=%d\n", __func__, typec->usbid_irqnum);	#if defined(CONFIG_MTK_LEGACY)	usdid = gpio_get_value(typec->usb_id_pin);#else	usdid = __gpio_get_value(typec->usb_id_pin);#endif		printk("%s usb_id_pin=%d\n", __func__, usdid);    if(usdid == 0) // this means otg is plugin        ret = request_irq(typec->usbid_irqnum, pi5usb_usbid_isr,IRQF_TRIGGER_HIGH, "pi5usb_usbid", typec);    else        ret = request_irq(typec->usbid_irqnum, pi5usb_usbid_isr,IRQF_TRIGGER_LOW, "pi5usb_usbid", typec);	if (ret < 0) {		pr_err("%s : failed to request irq\n", __func__);	}	return ret;}#elsestatic void cc_eint_interrupt_handler(void){    schedule_work(&pusb_i2c_data->eint_work);}#endifstatic int pi5usb_init_gpio(void){	int ret = 0;	pinctrl_select_state(g_exttypec->pinctrl, g_exttypec->pin_cfg->typec_as_int);	pinctrl_select_state(g_exttypec->pinctrl, g_exttypec->pin_cfg->typec_usb_id);#if defined(CONFIG_MTK_LEGACY)	printk("%s usb_id_pin=%d\n", __func__,  gpio_get_value(g_exttypec->usb_id_pin));#else	printk("%s usb_id_pin=%d\n",  __func__, __gpio_get_value(g_exttypec->usb_id_pin));#endif	return ret;}static int pi5usb_probe(struct i2c_client *client, const struct i2c_device_id *id){    struct usbtypc *typec;    char tx_buffer[2]={0x20,0x01};    char rx_buffer[4];    int ret;    printk("%s\n", __func__);    pi5usb_power_onoff(1);    pi5usb_init_gpio();    ret = pusb30216A_i2c_read(client, rx_buffer, 4);    if((ret <0) || (rx_buffer[0] != 0))    {    	dev_err(&client->dev, "attached pusb fail\n");        goto exit;    }            printk("%s %s\n", __func__, client->dev.driver->name);    if (!g_exttypec)    	g_exttypec = kzalloc(sizeof(struct usbtypc), GFP_KERNEL);    typec = g_exttypec;    typec->i2c_hd = client;       //intial code.    pusb30216A_i2c_write(typec->i2c_hd,tx_buffer,2);    mdelay(30);        tx_buffer[1]=0x04;    pusb30216A_i2c_write(typec->i2c_hd,tx_buffer,2);    //tx_buffer[1]=0x00;    //pusb30216A_i2c_write(typec->i2c_hd,tx_buffer,2);        INIT_WORK(&typec->eint_work, pusb_eint_work);    INIT_WORK(&typec->usbid_eint_work, pusb_usbid_eint_work);#ifdef CONFIG_OF    pi5usb_usbid_eint_init(typec);	pi5usb_eint_init(typec);#else    mt_eint_registration(CUST_EINT_CC_DECODER_NUM, CUST_EINTF_TRIGGER_FALLING, cc_eint_interrupt_handler, 0);// disable auto-unmask    mt_eint_unmask(CUST_EINT_CC_DECODER_NUM);#endif   // mt_set_gpio_out(175, 1);//temp solution for typeC-A detect!    schedule_work(&typec->eint_work);//insert cable power on.    schedule_work(&typec->usbid_eint_work);//insert cable power on.    return 0;    exit:    pi5usb_power_onoff(0);    return -1;}static int pi5usb_remove(struct i2c_client *client){	i2c_unregister_device(client);	kfree(i2c_get_clientdata(client));    pi5usb_power_onoff(0);    return 0;}static const struct i2c_device_id pi5usb_id[] = {	{ PI5USB30216A_I2C_NAME, 0 },	{ }};#ifdef CONFIG_OFstatic const struct of_device_id pi5usb_of_match[] = {		{.compatible = "mediatek,usb_type_c_pi5usb"},		{},	};#elsestatic struct i2c_board_info __initdata pi5usb_i2c_boardinfo[] = {	{		I2C_BOARD_INFO(PI5USB30216A_I2C_NAME, (0x1d)),	},};#endifstatic struct i2c_driver pi5usb_i2c_driver = {	.driver = {		.name = PI5USB30216A_I2C_NAME,		.owner = THIS_MODULE,#ifdef CONFIG_OF		.of_match_table = pi5usb_of_match,#endif		},	.probe		= pi5usb_probe,	.remove		= pi5usb_remove,	#if !defined(USE_EARLY_SUSPEND)        .suspend            = pi5usb_suspend,    .resume             = pi5usb_resume,    #endif	.id_table	= pi5usb_id,};static int usbc_pinctrl_probe(struct platform_device *pdev){	int retval = 0;	struct usbtypc *typec;	struct device_node *node = NULL;	unsigned int usb_id_pin;	printk("%s\n", __func__);	if (!g_exttypec)		g_exttypec = kzalloc(sizeof(struct usbtypc), GFP_KERNEL);	typec = g_exttypec;	typec->pinctrl = devm_pinctrl_get(&pdev->dev);	if (IS_ERR(typec->pinctrl)) {		printk("Cannot find usb pinctrl!\n");	} else {		typec->pin_cfg = kzalloc(sizeof(struct usbc_pin_ctrl), GFP_KERNEL);		printk("pinctrl=%p\n", typec->pinctrl);		typec->pin_cfg->typec_as_int = pinctrl_lookup_state(typec->pinctrl, "typec_as_int");		if (IS_ERR(typec->pin_cfg->typec_as_int))			printk("Can *NOT* find typec_as_int\n");		else			printk("Find typec_as_int\n");		typec->pin_cfg->typec_usb_id = pinctrl_lookup_state(typec->pinctrl, "typec_usb_id");		if (IS_ERR(typec->pin_cfg->typec_usb_id))			printk("Can *NOT* find typec_usb_id\n");		else			printk("Find typec_usb_id\n");		node = of_find_compatible_node(NULL, NULL, "mediatek,usb_c_pinctrl");		if (node)		{			if (of_property_read_u32_index(node, "typec_usbid_gpio", 1, &usb_id_pin)) {			    	printk("typec usb id gpio fail~~~\n");				g_exttypec->usb_id_pin = 0;			}			else {				g_exttypec->usb_id_pin = usb_id_pin;				printk("find typec_usbid_gpio = %x \n", g_exttypec->usb_id_pin);			}		}		printk("Finish parsing pinctrl\n");	}	return retval;}static int usbc_pinctrl_remove(struct platform_device *pdev){	return 0;}static const struct of_device_id usb_pinctrl_ids[] = {	{.compatible = "mediatek,usb_c_pinctrl",},	{},};static struct platform_driver usbc_pinctrl_driver = {	.probe = usbc_pinctrl_probe,	.remove = usbc_pinctrl_remove,	.driver = {		.name = "usbc_pinctrl",#ifdef CONFIG_OF		.of_match_table = usb_pinctrl_ids,#endif	},};static int __init pi5usb_i2c_init(void){	int ret = 0;	printk("typec %s enter. \n", __func__);	ret = platform_driver_register(&usbc_pinctrl_driver);	if (!ret) {		printk("register usbc pinctrl succeed!!\n");		ret = i2c_add_driver(&pi5usb_i2c_driver);		if (ret < 0)			printk("%s: failed to register pi5usb i2c driver",	__func__);		else			printk("pi5usb initialization succeed!!\n");	} else {		printk("register usbc pinctrl fail!!\n");	}	return ret;}static void __exit pi5usb_i2c_exit(void){	i2c_del_driver(&pi5usb_i2c_driver);}fs_initcall(pi5usb_i2c_init);//module_exit(pi5usb_i2c_exit);